<html lang="en">

  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>React</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
  </head>

  <style>
    .editable-text{
      cursor: pointer;
      width: fit-content;
      padding: 12px 0px;
      margin-top: 8px;
      border: 2px solid transparent;
      transition: 0.3s;
    }

    .editable-text:hover{
      border: 2px solid blue;
      transition: 0.3s;
    }

    ul{
      width: fit-content;
      border: 2px solid transparent;
      transition: 0.3s;
      list-style-type: decimal;
    }

    ul > ul{
      list-style-type: lower-latin;
    }

    ul > ul > ul{
      list-style-type: disc;
    }

    li{
      width: fit-content;
      border: 2px solid transparent;
      transition: 0.3s;
    }

    

    textarea{
      resize: none;
    }
  </style>

  <body>
    <div id="root"></div>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script type="text/javascript" src="https://unpkg.com/babel-standalone@6/babel.js"></script>
    
    <script type="text/babel">
    
    function App() {
      const [forceUpdate, setForceUpdate] = React.useState(false)
      const [exerciseElements, setExerciseElements] = React.useState([])

      function handleDelete(deletedSectionIndex){
        setExerciseElements(exerciseElements.filter((a, j) => j !== deletedSectionIndex).map(k => k))
      }

      function updateMainArray(updatedText, index){
        setExerciseElements(exerciseElements.map((e, i) => {
          if(i === index){
            return {...e, text: updatedText}
          }
          else{
            return e
          }
        }))
      }

      function updateQuestionsSection(updatedQuestionsArray, index){
        setExerciseElements(exerciseElements.map((e, i) => {
          if(i === index){
            return {...e, questions: updatedQuestionsArray}
          }
          else{
            return e
          }
        }))
      }

      function onHoverDelete(element){
        element.target.previousElementSibling.style.border = "2px solid red";
      }
      
      function outHoverDelete(element){
        element.target.previousElementSibling.style.border = "";
      }

      return <React.Fragment>
        <div>
          <button onClick={() => setExerciseElements([
            ...exerciseElements, {
              id: crypto.randomUUID(),
              type: "text",
              text: "lorem ipsum"
            }
          ])}>
            Add Text
          </button>
          <button onClick={() => setExerciseElements([
            ...exerciseElements, {
              id: crypto.randomUUID(),
              type: "questions",
              questions: []
            }
          ])}>
            Add Questions
          </button>
        </div>

        {exerciseElements.map((e, i) => <React.Fragment key={e.id}>
          {e.type === "text" ?
            <EditableText
              text={e.text}
              index={i}
              nestedArray={false}
              updateMainArray={updateMainArray}
            />
            :
            <List
              updt={forceUpdate}
              setUpdt={setForceUpdate}
              index={i}
              updateQuestionsSection={updateQuestionsSection}
            />
          }
          <button onClick={() => handleDelete(i)} onMouseEnter={onHoverDelete} onMouseLeave={outHoverDelete}>
            Delete Section
          </button>
        </React.Fragment>
        )}
        {console.log(exerciseElements)}
        {/*<List updt={forceUpdate} setUpdt={setForceUpdate} />*/}
      </React.Fragment>

    }

    function EditableText(props){
      const [isEditable, setIsEditable] = React.useState(props.isEditable);
      const [text, setText] = React.useState(props.text);
      
      

      return (
        <React.Fragment>
          {isEditable ? (
            <textarea
              className="w-100"
              onChange={(e) => {
                setText(e.target.value)
                props.nestedArray ? props.updateLocalArray(props.id) : props.updateMainArray(e.target.value, props.index)
              }}
              onBlur={() => {
                setIsEditable(false)
                props.nestedArray && props.forgetId()
              }}
              value={text}
              autoFocus
              id={props.id}
            >
            </textarea>
          ) : (
            
              
              <p onClick={() => setIsEditable(true)} className="editable-text me-5">
                {text}
              </p>
              
            
          )}
          
          
        </React.Fragment>
      )
    }

    function List(props){
      const [listArr, setListArr] = React.useState([
        {id: crypto.randomUUID(), text: "1"},
        {id: crypto.randomUUID(), text: "2"}
      ]);
      const [inputId, setInputId] = React.useState(null)

      React.useEffect(() => {
        props.updateQuestionsSection(listArr, props.index)
      }, [])

      function recurseUpdateArray(x, id, updatedText){
        return x.map(e => {
          if(Array.isArray(e)){
            return recurseUpdateArray(e, id, updatedText)
          }
          else{
            if(e.id === id){
              return {...e, text: updatedText}
            }
            else{
              return e
            }
          }
        })
      }

      function updateLocalArray(x){
        //console.log(nestedRef.current.children[2].children[0].value)
        //alert(nestedRef.current.children)
        //console.log(document.getElementById(x).value)
        setInputId(x)

        const updatedText = document.getElementById(x).value
        


        setListArr(recurseUpdateArray(listArr, x, updatedText))

        props.updateQuestionsSection(listArr, props.index)
        //console.log(listArr)
      }      

      
      function forgetId(){
        setInputId(null)
      }

      function onHoverDelete(element){
        element.target.previousElementSibling.style.border = "2px solid red";
      }
      
      function outHoverDelete(element){
        element.target.previousElementSibling.style.border = "2px solid transparent";
      }

      function recurse(arr) {
        
        return (
          <ul>

            
            
            {arr.map((e, indx, a) => 
              <React.Fragment key={indx}>
                {Array.isArray(e) ? recurse(e) : 

                  <React.Fragment>

                    {indx === 0 ? 
                      <React.Fragment>

                        <button onClick={() => {
                          a.push({id: crypto.randomUUID(), text: a.length + 1})
                          props.setUpdt(!props.updt)
                        }}
                        className="mt-2">
                          Add text element
                        </button>

                        <button onClick={() => {
                          a.push([{id: crypto.randomUUID(), text: indx + 1}])
                          props.setUpdt(!props.updt)
                        }}>
                          Append Sub-list
                        </button>

                        

                      </React.Fragment>
                     : (
                      null
                    )}

                    

                    

                    <li key={e.id}>
                        <EditableText
                          text={e.text}
                          id={e.id}
                          nestedArray={true}
                          updateLocalArray={updateLocalArray}
                          forgetId={() => setInputId(null)}
                          isEditable={e.id === inputId ? true : false}
                      />
                      
                      
                      
                    </li>

                    <button onClick={() => {
                      a.splice(indx, 1) 
                      props.setUpdt(!props.updt)
                    }}
                    onMouseEnter={onHoverDelete} onMouseLeave={outHoverDelete}>
                      Delete
                    </button>
                    
                  </React.Fragment>
                }
                
                

                  
              </React.Fragment>
            )}
            
          </ul>
        )
        
      }

      return (
        <React.Fragment>
          
          {/*<button onClick={() => setListArr([...listArr, <EditableText />])}>Add text element</button>
        <button onClick={() => setListArr([...listArr, [<EditableText />]])}>Append sub-list</button>*/}
          {recurse(listArr)}
          
        </React.Fragment>
      )
    }

    function SubArray(props){
      const [subArr, setSubArr] = React.useState(props.subArray)
    }

    // Render the component to the DOM
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
    </script>

  </body>

</html>